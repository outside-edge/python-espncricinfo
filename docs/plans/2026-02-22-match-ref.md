# MatchRef Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a `MatchRef` dataclass that gives users a typed, serializable value object for the `(series_id, match_id)` pair, replacing bare tuples returned by `get_recent_matches()` and `Summary().matches`.

**Architecture:** `MatchRef` lives in a new `espncricinfo/match_ref.py` module as a `@dataclass` with `series_id: int` and `match_id: int`. It supports `to_dict()`, `from_dict()`, `to_csv_row()`, `from_csv_row()`, `to_match()`, and `__iter__` (for backward-compatible tuple unpacking). `get_recent_matches()` in `match.py` is updated to return `list[MatchRef]` instead of `list[tuple]`. `Summary().matches` inherits the change automatically.

**Tech Stack:** Python 3.7+ dataclasses stdlib module, pytest, unittest.mock

---

### Task 1: Create `MatchRef` dataclass with fields and `__iter__`

**Files:**
- Create: `espncricinfo/match_ref.py`
- Create: `tests/test_match_ref.py`

**Step 1: Write the failing tests**

Create `tests/test_match_ref.py`:

```python
import unittest
from espncricinfo.match_ref import MatchRef


class TestMatchRefFields(unittest.TestCase):

    def test_fields_stored_as_int(self):
        ref = MatchRef(series_id=1478874, match_id=1478914)
        self.assertEqual(ref.series_id, 1478874)
        self.assertEqual(ref.match_id, 1478914)
        self.assertIsInstance(ref.series_id, int)
        self.assertIsInstance(ref.match_id, int)

    def test_string_inputs_coerced_to_int(self):
        ref = MatchRef(series_id="1478874", match_id="1478914")
        self.assertIsInstance(ref.series_id, int)
        self.assertIsInstance(ref.match_id, int)

    def test_tuple_unpacking(self):
        ref = MatchRef(series_id=1478874, match_id=1478914)
        series_id, match_id = ref
        self.assertEqual(series_id, 1478874)
        self.assertEqual(match_id, 1478914)

    def test_repr(self):
        ref = MatchRef(series_id=1478874, match_id=1478914)
        self.assertIn("1478874", repr(ref))
        self.assertIn("1478914", repr(ref))
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_match_ref.py -v
```

Expected: FAIL with `ModuleNotFoundError: No module named 'espncricinfo.match_ref'`

**Step 3: Create `espncricinfo/match_ref.py`**

```python
from __future__ import annotations
from dataclasses import dataclass


@dataclass
class MatchRef:
    """
    A lightweight reference to an ESPN Cricinfo match.

    Stores the ``series_id`` and ``match_id`` needed to construct a
    :class:`~espncricinfo.match.Match`. Supports dict and CSV serialization
    and tuple unpacking for backward compatibility.

    Example::

        from espncricinfo.match_ref import MatchRef

        ref = MatchRef(series_id=1478874, match_id=1478914)
        series_id, match_id = ref          # tuple unpacking still works
        m = ref.to_match()                 # hydrate a full Match object
        d = ref.to_dict()                  # {"series_id": 1478874, "match_id": 1478914}
        row = ref.to_csv_row()             # ["1478874", "1478914"]
    """

    series_id: int
    match_id: int

    def __post_init__(self):
        self.series_id = int(self.series_id)
        self.match_id = int(self.match_id)

    def __iter__(self):
        """Yield series_id then match_id — enables tuple unpacking."""
        yield self.series_id
        yield self.match_id
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_match_ref.py::TestMatchRefFields -v
```

Expected: 4 tests PASS

**Step 5: Commit**

```bash
git add espncricinfo/match_ref.py tests/test_match_ref.py
git commit -m "feat: add MatchRef dataclass with fields and tuple-unpacking support"
```

---

### Task 2: Add serialization methods (`to_dict`, `from_dict`, `to_csv_row`, `from_csv_row`)

**Files:**
- Modify: `espncricinfo/match_ref.py`
- Modify: `tests/test_match_ref.py`

**Step 1: Write the failing tests**

Add a new class to `tests/test_match_ref.py`:

```python
class TestMatchRefSerialization(unittest.TestCase):

    def setUp(self):
        self.ref = MatchRef(series_id=1478874, match_id=1478914)

    # --- to_dict ---

    def test_to_dict_returns_dict(self):
        self.assertIsInstance(self.ref.to_dict(), dict)

    def test_to_dict_keys(self):
        d = self.ref.to_dict()
        self.assertIn("series_id", d)
        self.assertIn("match_id", d)

    def test_to_dict_values_are_int(self):
        d = self.ref.to_dict()
        self.assertEqual(d["series_id"], 1478874)
        self.assertEqual(d["match_id"], 1478914)
        self.assertIsInstance(d["series_id"], int)
        self.assertIsInstance(d["match_id"], int)

    # --- from_dict ---

    def test_from_dict_round_trips(self):
        d = self.ref.to_dict()
        restored = MatchRef.from_dict(d)
        self.assertEqual(restored.series_id, self.ref.series_id)
        self.assertEqual(restored.match_id, self.ref.match_id)

    def test_from_dict_accepts_string_values(self):
        ref = MatchRef.from_dict({"series_id": "1478874", "match_id": "1478914"})
        self.assertEqual(ref.series_id, 1478874)
        self.assertEqual(ref.match_id, 1478914)

    # --- to_csv_row ---

    def test_to_csv_row_returns_list(self):
        self.assertIsInstance(self.ref.to_csv_row(), list)

    def test_to_csv_row_values_are_strings(self):
        row = self.ref.to_csv_row()
        self.assertEqual(row, ["1478874", "1478914"])
        for v in row:
            self.assertIsInstance(v, str)

    def test_to_csv_row_order_is_series_then_match(self):
        row = self.ref.to_csv_row()
        self.assertEqual(row[0], "1478874")   # series_id first
        self.assertEqual(row[1], "1478914")   # match_id second

    # --- from_csv_row ---

    def test_from_csv_row_round_trips(self):
        row = self.ref.to_csv_row()
        restored = MatchRef.from_csv_row(row)
        self.assertEqual(restored.series_id, self.ref.series_id)
        self.assertEqual(restored.match_id, self.ref.match_id)

    def test_from_csv_row_accepts_tuple(self):
        ref = MatchRef.from_csv_row(("1478874", "1478914"))
        self.assertEqual(ref.series_id, 1478874)
        self.assertEqual(ref.match_id, 1478914)
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_match_ref.py::TestMatchRefSerialization -v
```

Expected: FAIL with `AttributeError: 'MatchRef' object has no attribute 'to_dict'`

**Step 3: Add serialization methods to `espncricinfo/match_ref.py`**

Add these methods inside the `MatchRef` class, after `__iter__`:

```python
    def to_dict(self) -> dict:
        """Return ``{"series_id": int, "match_id": int}``."""
        return {"series_id": self.series_id, "match_id": self.match_id}

    @classmethod
    def from_dict(cls, d: dict) -> "MatchRef":
        """Construct from a mapping with ``series_id`` and ``match_id`` keys."""
        return cls(series_id=d["series_id"], match_id=d["match_id"])

    def to_csv_row(self) -> list:
        """Return ``[str(series_id), str(match_id)]`` for use with ``csv.writer``."""
        return [str(self.series_id), str(self.match_id)]

    @classmethod
    def from_csv_row(cls, row) -> "MatchRef":
        """Construct from a 2-element sequence ``[series_id, match_id]``."""
        return cls(series_id=row[0], match_id=row[1])
```

**Step 4: Run serialization tests**

```bash
uv run pytest tests/test_match_ref.py::TestMatchRefSerialization -v
```

Expected: 10 tests PASS

**Step 5: Run full test_match_ref.py**

```bash
uv run pytest tests/test_match_ref.py -v
```

Expected: all tests PASS

**Step 6: Commit**

```bash
git add espncricinfo/match_ref.py tests/test_match_ref.py
git commit -m "feat: add MatchRef serialization (to_dict, from_dict, to_csv_row, from_csv_row)"
```

---

### Task 3: Add `to_match()` method

**Files:**
- Modify: `espncricinfo/match_ref.py`
- Modify: `tests/test_match_ref.py`

**Step 1: Write the failing test**

Add to `tests/test_match_ref.py`:

```python
from unittest.mock import patch, MagicMock


class TestMatchRefToMatch(unittest.TestCase):

    def test_to_match_returns_match_instance(self):
        import json
        from pathlib import Path
        from espncricinfo.match import Match

        fixture_path = Path(__file__).parent / "fixtures" / "match_1478914_next_data.json"
        next_data = json.load(open(fixture_path))

        ref = MatchRef(series_id=1478874, match_id=1478914)
        with patch("espncricinfo.match._playwright_fetch", return_value=next_data):
            m = ref.to_match()
        self.assertIsInstance(m, Match)

    def test_to_match_passes_correct_ids(self):
        import json
        from pathlib import Path
        from espncricinfo.match import Match

        fixture_path = Path(__file__).parent / "fixtures" / "match_1478914_next_data.json"
        next_data = json.load(open(fixture_path))

        ref = MatchRef(series_id=1478874, match_id=1478914)
        with patch("espncricinfo.match._playwright_fetch", return_value=next_data):
            m = ref.to_match()
        self.assertEqual(m.match_id, 1478914)
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_match_ref.py::TestMatchRefToMatch -v
```

Expected: FAIL with `AttributeError: 'MatchRef' object has no attribute 'to_match'`

**Step 3: Add `to_match()` to `espncricinfo/match_ref.py`**

Add this import at the top of the file (use `TYPE_CHECKING` to avoid circular import):

```python
from __future__ import annotations
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from espncricinfo.match import Match
```

Add this method to the `MatchRef` class:

```python
    def to_match(self) -> "Match":
        """
        Hydrate a full :class:`~espncricinfo.match.Match` object.

        Triggers a Playwright fetch — use only when you need full match data.
        """
        from espncricinfo.match import Match
        return Match(self.match_id, self.series_id)
```

Note: the local import inside `to_match()` avoids a circular import
(`match.py` will import `MatchRef`; `match_ref.py` must not import `Match` at
module level).

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_match_ref.py::TestMatchRefToMatch -v
```

Expected: 2 tests PASS

**Step 5: Run full suite to confirm nothing broke**

```bash
uv run pytest tests/ -k "not integration" -q
```

Expected: all existing tests pass

**Step 6: Commit**

```bash
git add espncricinfo/match_ref.py tests/test_match_ref.py
git commit -m "feat: add MatchRef.to_match() to hydrate a full Match object"
```

---

### Task 4: Update `get_recent_matches()` to return `list[MatchRef]`

**Files:**
- Modify: `espncricinfo/match.py` (around line 692–725: `get_recent_matches`)
- Modify: `tests/test_match.py` (integration test that calls `get_recent_matches`)

**Step 1: Write/update the failing test**

In `tests/test_match.py`, find `TestMatchIntegration` and add:

```python
    @pytest.mark.integration
    def test_live_get_recent_matches_returns_match_refs(self):
        from espncricinfo.match_ref import MatchRef
        results = Match.get_recent_matches()
        assert len(results) > 0
        assert all(isinstance(r, MatchRef) for r in results)
```

Also add a unit-level test to `tests/test_match_ref.py` that mocks `_playwright_fetch` and verifies `get_recent_matches` returns `MatchRef` objects. Add this class:

```python
class TestGetRecentMatchesReturnsMatchRef(unittest.TestCase):

    def test_get_recent_matches_returns_list_of_match_refs(self):
        import json
        from pathlib import Path
        from espncricinfo.match import Match
        from espncricinfo.match_ref import MatchRef

        # Load a minimal __NEXT_DATA__ fixture that has match results
        fixture_path = Path(__file__).parent / "fixtures" / "match_1478914_next_data.json"
        next_data = json.load(open(fixture_path))

        with patch("espncricinfo.match._playwright_fetch", return_value=next_data):
            results = Match.get_recent_matches("2026-02-06")

        # Even if the fixture doesn't have results page data, the return must be a list
        self.assertIsInstance(results, list)
        for r in results:
            self.assertIsInstance(r, MatchRef)
```

**Step 2: Run the unit test to verify it fails**

```bash
uv run pytest tests/test_match_ref.py::TestGetRecentMatchesReturnsMatchRef -v
```

Expected: FAIL — `get_recent_matches` still returns tuples

**Step 3: Update `match.py`**

At the top of `espncricinfo/match.py`, add the import:

```python
from espncricinfo.match_ref import MatchRef
```

In `get_recent_matches()`, find the line:

```python
results.append((series_id, match_id))
```

Replace it with:

```python
results.append(MatchRef(series_id=series_id, match_id=match_id))
```

**Step 4: Run the unit test to verify it passes**

```bash
uv run pytest tests/test_match_ref.py::TestGetRecentMatchesReturnsMatchRef -v
```

Expected: PASS (or gracefully skipped/empty if fixture has no results data — the list must be empty, not contain tuples)

**Step 5: Run full suite**

```bash
uv run pytest tests/ -k "not integration" -q
```

Expected: all tests pass

**Step 6: Commit**

```bash
git add espncricinfo/match.py tests/test_match.py tests/test_match_ref.py
git commit -m "feat: get_recent_matches() now returns list[MatchRef] instead of list[tuple]"
```

---

### Task 5: Update `Summary` docstring and `test_summary.py`

**Files:**
- Modify: `espncricinfo/summary.py` (docstring only)
- Modify: `tests/test_summary.py`

**Step 1: Update `test_summary.py` to use `MatchRef`**

In `tests/test_summary.py`, update `FAKE_MATCHES` from a list of tuples to a list of `MatchRef` objects, and update the assertions:

```python
import unittest
from unittest.mock import patch

from espncricinfo.match_ref import MatchRef
from espncricinfo.summary import Summary


FAKE_MATCHES = [
    MatchRef(series_id=1478874, match_id=1478914),
    MatchRef(series_id=1234567, match_id=1234568),
]


class TestSummary(unittest.TestCase):

    def test_summary_matches_is_list(self):
        with patch("espncricinfo.summary.Match.get_recent_matches",
                   return_value=FAKE_MATCHES):
            s = Summary()
            self.assertIsInstance(s.matches, list)

    def test_summary_matches_returns_match_refs(self):
        with patch("espncricinfo.summary.Match.get_recent_matches",
                   return_value=FAKE_MATCHES):
            s = Summary()
            self.assertEqual(len(s.matches), 2)
            for ref in s.matches:
                self.assertIsInstance(ref, MatchRef)

    def test_summary_passes_date_to_get_recent_matches(self):
        with patch("espncricinfo.summary.Match.get_recent_matches",
                   return_value=[]) as mock_grm:
            Summary(date="2026-02-22")
            mock_grm.assert_called_once_with("2026-02-22")

    def test_summary_no_date_calls_get_recent_matches_with_none(self):
        with patch("espncricinfo.summary.Match.get_recent_matches",
                   return_value=[]) as mock_grm:
            Summary()
            mock_grm.assert_called_once_with(None)

    def test_summary_matches_support_tuple_unpacking(self):
        with patch("espncricinfo.summary.Match.get_recent_matches",
                   return_value=FAKE_MATCHES):
            s = Summary()
            series_id, match_id = s.matches[0]
            self.assertEqual(series_id, 1478874)
            self.assertEqual(match_id, 1478914)
```

**Step 2: Run tests to see what fails**

```bash
uv run pytest tests/test_summary.py -v
```

Expected: `test_summary_matches_returns_match_refs` and `test_summary_matches_support_tuple_unpacking` PASS (since `get_recent_matches` now returns `MatchRef`); `test_summary_matches_returns_tuples` no longer exists. Confirm all 5 pass.

**Step 3: Update `summary.py` docstring**

Replace the docstring example in `espncricinfo/summary.py`:

```python
class Summary:
    """
    Provides a list of recent matches as :class:`~espncricinfo.match_ref.MatchRef` objects.

    Uses Match.get_recent_matches() which scrapes the ESPN Cricinfo
    results page via Playwright. Pass an optional date string (YYYY-MM-DD
    or DD-MM-YYYY) to get matches for a specific day; defaults to today.

    Example::

        from espncricinfo.summary import Summary

        for ref in Summary().matches:
            m = ref.to_match()
            print(m.description)

        # Tuple unpacking also works:
        for series_id, match_id in Summary().matches:
            print(series_id, match_id)
    """

    def __init__(self, date=None):
        self.matches = Match.get_recent_matches(date)
```

**Step 4: Run full suite**

```bash
uv run pytest tests/ -k "not integration" -q
```

Expected: all tests pass

**Step 5: Commit**

```bash
git add espncricinfo/summary.py tests/test_summary.py
git commit -m "docs/test: update Summary docstring and tests for MatchRef return type"
```

---

### Task 6: Final verification

**Step 1: Run full suite**

```bash
uv run pytest tests/ -k "not integration" -v
```

Expected: all tests pass, 0 failures, 0 errors

**Step 2: Confirm `MatchRef` is importable from the package**

```bash
uv run python -c "from espncricinfo.match_ref import MatchRef; print(MatchRef(1478874, 1478914))"
```

Expected: `MatchRef(series_id=1478874, match_id=1478914)`

**Step 3: Commit any remaining changes**

```bash
git status
# If anything unstaged:
git add -p
git commit -m "chore: cleanup after MatchRef implementation"
```
